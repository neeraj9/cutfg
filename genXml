#!/usr/bin/perl
#
# GenXml - Version 0.1, A C Check unit testing framework generator
#                       (XML generator)
# -----------------------------------------------------------------
# http://cutfg.sourceforge.net
#
# The following script part of code derived from ScanDoc
#       http://scandoc.sourceforge.net/
#
require "ctime.pl";
require "getopts.pl";

# 1 = on (verbose); 0 = off 
$debug = 0;

# Get the current date
$date = &ctime(time);
if ($debug)
{
	print "date = $date\n";
}

# Set the default tab size
$tabSize = 4;

$minorVersion = 1;
$majorVersion = 0;
$prgURL   = "http://cutfg.sourceforge.net/";
$xmlscriptdtd = "http://cutfg.sourceforge.net/xmldtd/xmlscript.dtd";


# Global variables for unit testing framework
# generation
# The format is 
#  int fn1(int arg);2;char fn2(void);0;...
# where 2 is the num of switch cases in function fn1()
# where 0 is the num of switch cases in function fn2()
# ... etc
$parseResult = ""; 
# names of all functions delimited by ';'
#$fnames = "";
$suitename = "";
$filename = "";

# Set up default templates
&Getopts( 'd:s:' );

if ($#ARGV < 0) {
  die "Usage: -d <output-path> [ -s ] [ <input-files> ... ]\n -s for silent work\n";
}

# Set the destination path.
$destPath = "";
$destPath = $opt_d if (defined($opt_d));
$silent = 0;
$silent = 1 if (defined($opt_s));

if ($silent)
{
	$debug = 0;
}

# For each input filename, parse it
while ($srcfile = shift(@ARGV)) {

  $linenumber = 0;
  open( FILE, $srcfile ) || die "Can't open file $srcfile\n";
if ($debug)
{
  print STDERR "Reading \"$srcfile\"\n";
} 
  $_ = '';
  
  while (&parseDeclaration( '' )) {}


  # This is the result accumulated
if ($debug)
{
  print "Result\n";
  print "------------------ ----------\n";
  print "function prototype;NumOfCases;labels;...\n";
  print "------------------ ----------\n";
  print "$parseResult\n";
}

  $filename = $srcfile;
	#print $srcfile;
	while ($filename =~ /\//)
	{
		$filename =~ s/[\.\w-\\ ]*\///;
		#print "\n$filename";
	}
  $suitename = $filename;
  # The name of test suite is same as the filename
  $suitename =~ s/\.\w*$//; # strip the .c part
  $suitename =~ s/^(\w*\/)*//; # strip the paths leaving
  # only the name of the file

  &genUnitTestFramework;

}


exit;

# ======================= Subroutines ================================

# Read a line of input, and remove blank lines and preprocessor directives.
sub rdln {
  my ($skip_next_line) = 0;
  if (defined ($_)) {
    my ($previous_line) = $_;
    while ( (/^(\s*|\#.*)$/ || $skip_next_line ) && ($_ = <FILE>)) {
      if ($previous_line =~ m/\\\s*/) { $skip_next_line = 1; }
      else { $skip_next_line = 0; }
      $previous_line = $_;
      $linenumber++; 
			
      if ($debug) {
				print STDERR "(0:$srcfile) $linenumber. --> "; 
				print STDERR "<line>$_</line>\n";
			} 
    }
  }
}

# Don't skip "#"
sub rdln2 {
  if (defined ($_)) {
    while (/^(\s*)$/ && ($_ = <FILE>)) {$linenumber++; if ($debug) { print STDERR "(0:$srcfile) $linenumber.\n"; } }
  }
}

# Remove comments from current line
sub removeComment {
  s|//.*||;
}

# parsing functions
sub matchKW		{ &rdln; return (s/^\s*($_[0])//, $1) if defined ($_); return (0, 0); }
#sub matchStruct		{ &rdln; return (s/^\s*(struct|class)//, $1) if defined ($_); return (0, 0); }
#sub matchPermission	{ &rdln; return (s/^\s*(public|private|protected)// && $1) if defined ($_); return (0,0); }
sub matchID		{ &rdln; return (s/^\s*([A-Za-z_]\w*)//, $1) if defined ($_); return (0,0); }
sub matchColon		{ &rdln; return (s/^\s*\://) if defined ($_); return 0; }
sub matchComma		{ &rdln; return (s/^\s*\,//) if defined ($_); return 0; }
sub matchSemi		{ &rdln; return (s/^\s*\;//) if defined ($_); return 0; }
sub matchRBracket	{ &rdln; return (s/^\s*\{//) if defined ($_); return 0; }
sub matchLBracket	{ &rdln; return (s/^\s*\}//) if defined ($_); return 0; }
sub matchRParen		{ &rdln; return (s/^\s*\(//) if defined ($_); return 0; }
sub matchLParen		{ &rdln; return (s/^\s*\)//) if defined ($_); return 0; }
sub matchRAngle		{ &rdln; return (s/^\s*\<//) if defined ($_); return 0; }
sub matchLAngle		{ &rdln; return (s/^\s*\>//) if defined ($_); return 0; }
sub matchDecl           { &rdln; return (s/^(\s*[\s\w\*\[\]\~\&\n\:]+)//, $1) if defined ($_); return (0, 0); }
sub matchOper		{ &rdln; return (s/^\s*([\~\&\^\>\<\=\!\%\*\+\-\/\|\w]*)// && $1) if defined ($_); return 0; }
sub matchFuncOper	{ &rdln; return (s/^\s*(\(\))// && $1) if defined ($_); return 0; }
sub matchAny		{ &rdln; return (s/^\s*(\S+)//, $1) if defined ($_); return (0, 0); }
sub matchChar		{ &rdln; return (s/^(.)//, $1) if defined ($_); return (0, 0); }
sub matchChar2	        { &rdln2; return (s/^(.)//, $1) if defined ($_); return (0, 0); }
sub matchString 	{ &rdln; return (s/^\"(([^\\\"]|(\\.)))*\"//, $1) if defined ($_); return (0, 0); }

# Skip to next semicolon
sub skipToSemi {
  
  while (!&matchSemi) {
    
    &rdln;
    s|//.*||;			# Eat comments
      if (&matchLBracket) {
	&skipBody;
	next;
      }
    last if !s/^\s*([^\s\{\;]+)//;
    # print STDERR "$1 ";
  }
}

# Skip function body
sub skipBody {
  local( $nest );
  
  $nest = 1;
  for (;;) {
    if (&matchRBracket) { $nest++; }
    elsif (&matchLBracket) {
      $nest--;
      last if !$nest;
    }
    else { 
      last if ((($valid,) = &matchKW( "[^\{\}]")) && !$valid);
    }
  }
}

# Skip a string. (multiline)
sub skipString {
  local( $char, $lastchar);
  $lastchar = "\"";
  
  for (;;) {
    ($valid, $char) = &matchChar2;
    if (($char eq "\"") && ($lastchar ne "\\")) { last; }
    if ($lastchar eq "\\") { $lastchar = " "; }
    else { $lastchar = $char; }
  }
}


# Skip everything in parenthesis.
sub skipParenBody {
  local( $nest );
  
  $nest = 1;
  
  for (;;) {
    if (&matchRParen) { $nest++; }
    elsif (&matchLParen) {
      $nest--;
      last if !$nest;
    }
    else { 
      last if ((($valid,) = &matchKW( "[^\(\)]")) && !$valid);
    }
  }
}

# Parse (*name) syntax
sub parseParenPointer {

  $parenPointerFunction = "";

  if (s/^(\s*\(\s*\*)//) {
    $decl .= $1;
    $nest = 1;
    
    for (;;) {
      # Preserve spaces, eliminate in-line comments
      &removeComment;
      while (s/^(\s+)//) { $decl .= $1; &rdln; }
      
      if (&matchRParen) { $nest++; $decl .= "("; }
      elsif (&matchLParen) {
	$decl .= ")";
	$nest--;
	last if !$nest;
      }
      elsif ((($valid, $d) = &matchKW( "[^\(\)]*")) && $valid) { $decl .= $d; }
      else { last; }
    }
    
    # Just in case there are array braces afterwards.
    while ((($valid, $d) = &matchDecl) && $valid) { $decl .= $d; }
    $parenPointerFunction = $decl;
    $parenPointerFunction =~ s/^\s+//;	# Remove whitespace from beginning
    $parenPointerFunction =~ s/\s+$//;	# Remove whitespace from end
  }
}

# Parse template arguments
sub matchAngleArgs {
  
  if (&matchRAngle) {
    local ($args, $nest);
    
    $args = "&lt;";
    $nest = 1;
    
    for (;;) {
      if (&matchRAngle) { $nest++; $args .= "&lt;"; }
      elsif (&matchLAngle) {
	$nest--;
	$args .= "&gt;";
	last if !$nest;
      }
      elsif ((($valid, $d) = &matchChar) && $valid) { $args .= $d; }
      else { last; }
    }
    return $args;
  }
  else { return ''; }
}

# convert tabs to spaces
sub expandTabs {
  local	($text) = @_;
  local 	($n);
  
  while (($n = index($text,"\t")) >= 0) {
    substr($text, $n, 1) = " " x ($tabSize-($n % $tabSize));
  }
  
  return $text;
}

# Parse a declaration in the file
sub parseDeclaration {
  
  local ($context) = @_;
  local ($baseScope) = '';
  local ($decl);
	local ($loopCounter);
	local ($maxLoopCounter);
  my ($token);
  
  if ($context) { $baseScope = $context . "::"; }
  
	if ($debug)
	{
			 print STDERR "<parseDeclaration>$_</parseDeclaration>\n";
	}
  &rdln;

  if (!defined ($_)) { return 0; }
  
  if (s|^\s*//||) { 
    # Ordinary C++ comment
    $_ = '';
    &rdln;
  }
  elsif (s|^\s*\/\*||) {
    # Ordinary C comment
    $text = "";
    
    while (!/\*\//) { $text .= $_; $_ = <FILE>; $linenumber++; if ($debug) { print STDERR "(2) $linenumber\n."; }}
    /\*\//;
    $text.= $`; $_ = $';
  }
  elsif ((($valid, $tag) = &matchKW( "template")) && $valid) {
    # Template definition
    $args = &matchAngleArgs;
    &rdln;
    
    ##$tmplParams = $args; JAMES
    $result = &parseDeclaration( $context );
    ##$tmplParams = ''; JAMES
    return $result;
  }
  elsif ((($valid, $tag) = &matchKW("class|struct")) && $valid) {
    # Class or structure definition
    local ($className,$class);
    
    if ((($valid, $className) = &matchID) && $valid) {
      
      return 1 if (&matchSemi);		# Only a struct tag
      
      # A class instance
      if ((($valid,)=&matchID) && $valid) {
	&matchSemi;
	return 1;
      }
      
      my $fullName = "$baseScope$className"; ##$tmplParams"; JAMES
      # print STDERR "CLASS $fullName\n";
      
      my @bases = ();
      
      if (&matchColon) {
	
	# check if the code can hand here (NEERAJ)
	for (;;) {
	  my $p;
	  &matchKW( "virtual" );
	  $perm = "private";
	  if ((($valid, $p) = &matchKW( "public|private|protected" )) && $valid) { $perm = $p; }
	  &matchKW( "virtual" );
	  
	  last if !(  (($valid, $base) = &matchID) && $valid  );
	  
	  push @bases, $base;
	  push @{ $subclasses{ $base } }, $fullName;
	  # print STDERR " : $perm $base\n";
	  last if !&matchComma;
	}
      }
      
      #	print STDERR "\n";
      # print STDERR "parsing class $fullName\n";

      if ($docEmpty == 0) {
	$class = { 'type'    => $tag,
		   'name'    => $fullName,
		   'longname'=> "$tag $className",
		   'fullname'=> "$tag $className",
		   'scopename'=> "$tag $fullName",
		   'uname'   => $fullName,
		   'bases'   => \@bases,
		   'package' => $packageName,
		   'members' => {} };
	
	# print STDERR "$className: @bases\n";
	
	bless $class, ClassRecord;
	
	if ($debug)
	{
		print STDERR "   parsing class $fullName\n";
	}
	# $classToPackage{ $className } = $packageName;
	$classToPackage{ $fullName } = $packageName;
	# $classList{ $className } = $class;
	$classList{ $fullName } = $class;
	$packages{ $packageName }{ 'classes' }{ $fullName } = $class;
	&dumpComments( $class );
      }
      
      if (&matchRBracket) {
	local ($perm) = ("private");
	
	while (!&matchLBracket) {
	  my $p;
	  if ((($valid, $p) = &matchKW( "public\:|private\:|protected\:" )) && $valid) {
	    $perm = $p;
	  }
	  else {
	    &parseDeclaration( $fullName )
	      || die "Unmatched brace! line = $linenumber\n";
	  }
	}
	
	&matchSemi;
      }
      
      &clearComments;
    }
  }
  elsif ( ((($valid,)=&matchKW( "enum")) && $valid) || ((($valid,)=&matchKW( "typedef" )) && $valid)) {
    &skipToSemi;
  }
  elsif ((($valid,)=&matchKW( "friend\s*class" )) && $valid) {
    &skipToSemi;
  }
  elsif ((($valid, $token) = &matchKW("extern\\s*\\\"C\\\"")) && $valid) {
    &matchRBracket;
    while (!&matchLBracket) {
      &parseDeclaration( '' ) || die "Unmatched brace! line = $linenumber\n";
    }
    &matchSemi;
  }
  # elsif ($kw = &matchID) {
  #   $type = "$kw ";
  #
  #   if ($kw =~/virtual|static|const|volatile/) {
  #	$type .= &typ;
  #   }
  # }
  elsif ((($valid, $decl) = &matchDecl) && $valid) {
    my ($instanceClass) = "";
    
		# NEERAJ
    # print STDERR "1) DECLARATION=$decl, REST=$_, baseScope=$baseScope, VALUE=$valid\n";

    return 1 if ($decl =~ /^\s*$/);

		# NEERAJ
		# print STDERR "1.1) DECLARATION=$decl\n";

    if (!($class)) {
      if ($decl =~ s/(\S*\s*)(\S+)\:\:(\S+)\s*$/$1$3/) {
				# print STDERR "1.1.1) DECLARATION=$decl\n";
        $instanceClass = $2;
      }
    }

    # Eliminate in-line comments
    &removeComment;
		
    
    # Check for multi-line declaration
    while ((($valid, $d) = &matchDecl) && $valid) {
			$decl .= $d;
			# NEERAJ
			# print STDERR "2) DECLARATION=$decl, REST=$_,";
			# print STDERR "baseScope=$baseScope, VALUE=$valid\n";
		}
    
    # Handle template args, but don't let operator overloading confuse us!
    $tempArgs = '';
    if (!($decl =~ /\boperator\b/) && ($tempArgs = &matchAngleArgs)) {
      $tempArgs = $decl . $tempArgs;
      $decl = '';
      while ((($valid, $d) = &matchDecl) && $valid) { $decl .= $d; }
    }
    
    # Look for (*name) syntax
    &parseParenPointer;
    
    # Special handling for operator... syntax
    $oper = "";
    if ($decl =~ s/\boperator\b(.*)/operator/) {
      $oper = $1;
      $oper .= &matchOper;
      # If, after all that there's no opers, then try a () operator
      if (!($oper =~ /\S/)) { $oper .= &matchFuncOper; }
    }

    ($type,$mod,$decl) = $decl =~ /([\s\w]*)([\s\*\&]+\s?)(\~?\w+(\[.*\])*)/;
		# NEERAJ: in case of a function get the name of the function
		# print STDERR "DECLARATION=$decl\n"; 
    
    if ($parenPointerFunction) {
      $decl=$parenPointerFunction;
			# NEERAJ: dont reach here in case of a function
    }
    
    $type = $tempArgs . $type;
    $decl .= $oper;
		# NEERAJ: $oper has no significance in case of functions

    if ($mod =~ /\s/) { $type .= $mod; $mod = ""; }
		# NEERAJ: $mod has no significance in case of functions
    
    for (;;) {
      
			# NEERAJ
      # print STDERR "Looping (type/mod/decl): $type/$mod/$decl\n";
      
      if (&matchRParen) {
	$nest = 1;
	$args = "";
	
	for (;;) {
	  # print STDERR "Argloop $_\n";
	  
	  # Process argument lists.
	  
	  # Preserve spaces, eliminate in-line comments
	  # REM: Change this to save inline comments and automatically
	  # generate @param clauses
	  s|//.*||;
	  while (s/^(\s+)//) { $args .= " "; &rdln; }
	  
	  if (&matchRParen) { $nest++; $args .= "("; }
	  elsif (&matchLParen) {
	    $nest--;
	    last if !$nest;
	    $args .= ")";
	  }
	  elsif ((($valid, $d) = &matchKW( "[\,\=\.\:\-]" )) && $valid) { $args .= $d; }
	  elsif ((($valid, $d) = &matchDecl) && $valid) { $args .= $d; }
	  elsif ((($valid, $d) = &matchAngleArgs) && $valid) { $args .= $d; }
	  elsif ((($valid, $d) = &matchString) && $valid) { $args .= "\"$d\""; }
	  else { last; }
	}
	 # NEERAJ		
	 # print function prototype
	 $fnproto = $type . $mod . $baseScope . $decl . "($args);";

	 #$fnames .= $decl . ";";
	 #$fnames =~ s/\s*//g; # remove all wide spaces from function name
	 
	 # When a new function begins in the same line a function ends
	 # example.
	 # int fn1()
	 # {
	 #   ... whatever ....
	 # } int fn2()
	 # {
	 #  .... whatever ...
	 # }
	 # then a space can come before the function type, so remove it
	 $fnproto =~ s/^\s* //; # remove the beginning wide space (\ \r\n\t)
	 # replace \n (newline) with ' ' (space)
	 $fnproto =~ s/\n/ /;
	 # print STDERR "$type$mod$baseScope$decl($args);\n";
	 #print STDERR "$fnproto\n";
	 &rdln; # it automatically skips over blank lines and # (preprocessor cmds)
	 #print "<>$_</>";
	 $block = &extractBlock;
	if ($debug)
	{
		print "Fn body extracted\n";
		print "<block>$block</block>\n";
	}
	
	($numSwitchCases,$switchCases) = &getNumCases($block);
	#print "num cases = $numSwitchCases\n";
	# $fnproto already has a terminating ';'
	# Append the current function to the list
	$parseResult .= $fnproto . "$numSwitchCases;"."$switchCases;";
	&matchKW( "const" );
	
	s|//.*||;
	
	# Constructor super-call syntax
	if (&matchColon) {
	  
	  # Skip over it.
	  for (;;) {
	    &rdln;
	    last if /^\s*(\{|\;)/;
	    last if !((($valid,)=&matchAny) && $valid);
	  }
	}
	
	last if &matchSemi;
	if (&matchRBracket) { &skipBody; last; }
	last if !&matchComma;
	last if !((($valid, $decl) = &matchDecl) && $valid);
	
	# Look for (*name) syntax
	&parseParenPointer;
	
	$decl =~ s/^\s*//;
	$oper = "";
	if ($decl =~ /\boperator\b/) {
	  $decl =~ s/\boperator\b(.*)/operator/;
	  $oper = $1 . &matchOper;
	}
	($mod,$d) = $decl =~ /^\s*([\*\&]*)\s*(\~?\w+(\[.*\])*)/;
	$decl .= $oper;
	$decl = $d if $d ne "";
      }
      else {
	s|//.*||;
	
	$final = 0;
	
	if ((($valid,)=&matchKW( "\=" )) && $valid) {
	  for (;;) {
				$matchedAny = 0;
	    if (&matchRBracket) {
	      &skipBody;
	      $final = 1;
	      last;
	    }
	    
	    if (&matchSemi) {
	      $final = 1;
	      last;
	    }
	    
	    # var = new ... (...)
	    if ((($valid,)=&matchKW("new")) && $valid) {
				$matchedAny = 1;
	      &matchKW("[A-Za-z_0-9 ]*");
	      if (&matchRParen) {
	        &skipParenBody;
	      }
	    }
	    
	    # var = (.....) ...
	    if (&matchRParen) {
	      &skipParenBody;
				$matchedAny = 1;
	    }
	    
	    # var = ... * ...
	    ($valid,$matchedstr) = &matchKW ("[\/\*\-\+]*");
			if ($matchedstr)
			{
				$matchedAny = 1;
			}
	    
	    # var = "..."
	    if ((($valid,) = &matchKW ("[\"]")) && $valid) {
	      &skipString;
				$matchedAny = 1;
	    }
	    #&matchString;
	    
	    last if /^\s*,/;
	    #last if !((($valid,)=&matchAny) && $valid);
	    last if !((($valid,)=&matchKW("[A-Za-z_0-9 \-]*")) && $valid);
	    if (&matchSemi) {
	        $final = 1;
	        last;
	    }
			last if !($matchedAny);
	  }
		if ($matchedAny == 0)
		{
			if ($silent == 0)
			{
				print "Unrecognised file format (expected C file)\n";
			}
			exit(2);
		}
	}
	
	s|//.*||;
	
	# void ~*&foo[];
	# void foo[];
	# void far*foo[];
	# print STDERR "Decl: $type$mod$baseScope$decl;\n";
	
	last if $final;
	last if &matchSemi;
	last if !&matchComma;
	last if !((($valid, $decl) = &matchDecl) && $valid);
	
	# Look for (*name) syntax
	&parseParenPointer;
	
	$decl =~ s/^\s*//;
	($mod,$d) = $decl =~ /^\s*([\*\&]*)(\~?\w+(\[.*\])*)/;
	$decl = $d if $d ne "";
      }
    }
  }
  elsif ($context ne "" && /^\s*\}/) {
    # print STDERR "Popping!\n";
    return 1;
  }
  elsif (&matchRBracket) {
    &skipBody;
  }
  elsif ((($valid, $token) = &matchAny) && $valid) {
    # Comment in for debugging
    # print STDERR "token: $token \n";
  }
  else { return 0; }
  
  return 1;
}


sub removeCC {

	if (/\/\*/)
	{
		#print "comment is present\n";
		$notDone1 = 1;
		while ($notDone1 > 0)
		{
			if (/\*\//)
			{
				$notDone1 = 0;
				$_ = s/^.*\*\///;
			}
			else
			{
				$_ = ""; # very important
				&rdln;
			}
		}
	}
}

sub removeCComments {
  if (s|^\s*\/\*\*\s+||) {
    # Special C comments
    
    s/\={3,}|\-{3,}|\*{3,}//;			# Eliminate banner strips
    $text = '';
    $docTag = 'description';
    
    # Special comment
    while (!/\*\//) { &handleCommentLine( $_ ); $text .= $_; $_ = <FILE>; $linenumber++; if ($debug) { print STDERR "(1) $linenumber\n."; }}
    s/\={3,}|\-{3,}|\*{3,}//;			# Eliminate banner strips
    /\*\//;
    &handleCommentLine( $` );
    $text.= $`; $_ = $';
  }
  elsif (s|^\s*\/\*||) {
    # Ordinary C comment
    $text = "";
    
    while (!/\*\//) { $text .= $_; $_ = <FILE>; $linenumber++; if ($debug) { print STDERR "(2) $linenumber\n."; }}
    /\*\//;
    $text.= $`; $_ = $';
  }
}


# Non recursive impementaion of block extraction.
# A block is anything between '{' and '}'
# Note that braces can be nested :)
sub extractBlock {

	if ($debug)
	{
		print STDERR "<ExtractingBlock>\n";
	}
	my ($block); # function implementation block
	 $block = '';
	 #&rdln; # it automatically skips over blank lines and # (preprocessor cmds)
	 #print "<>$_</>";
	 if (/\{/)
	 {
		$notDone = 1;
		$braceLevel = 0;
		# read the entire { ... } ... block in $block
		while ($notDone > 0){
			if ($debug)
			{
				print STDERR "depth = $braceLevel\n";
			}
			$block = $block . $_;
			$_ =~ s/\n//g; # strip the newline char; although not needed
				if ($debug)
				{
					print STDERR "<currentBuf>$_</currentBuf>\n";
				}

			# print "before- [$_]\n";
			$block .= &stripComment; # return any extra char read from file as raw text
				if ($debug)
				{
					print STDERR "<currentBuf>$_</currentBuf>\n";
				}

			# print "after- [$_]\n";
			#print "outerloop: ";
			while (/[\}\{]/){
				if (/\}/){
					$closeBracePos = $-[0];
					if ($debug)
					{
						print STDERR  "close = $closeBracePos\n";
					}
					if (/\{/){
						#print "$_ :";
						#print "neeraj\n";
						$openBracePos = $-[0];
						if ($debug)
						{
							print STDERR "open = $openBracePos\n";
							print STDERR "depth = $braceLevel\n";
						}
						if ($closeBracePos < $openBracePos)
						{
							if ($braceLevel > 1)
							{
								$_ =~ s/\}//; # stip it
								$_ =~ s/\{//; # stip it
								# no need to touch $braceLevel because
								# both { and } are present
							}
							else
							{
								$notDone = 0;
							}
						}
						else
						{
							# if '{' is also present in the same line but
							# comes before '}' so that another depth/level
							# is added in the braces
							$_ =~ s/\}//; # stip it
							$_ =~ s/\{//; # stip it
							$braceLevel++;
						}
					}
					else
					{
						# if '{' is not present then check the
						# braceLevel and match the nested '{' if so
						# otherwise the work is done
						$_ =~ s/\}//; # stip it
						#print "$braceLevel";
						if ($braceLevel > 1)
						{
							$braceLevel--;
						}
						else
						{
							# when all the braces are matched then
							# $braceLevel =~ 1
							$braceLevel--;
							# now it is 0
						  #print "at last\n";
							$notDone = 0;
						}
					}
				}
				else{
					# if '}' is not present then 
					# match is not complete
					# so carry on....
					#print "NEERAJ\n";
					if (/\{/){
						$openBracePos = $-[0];
						if ($debug)
						{
							print STDERR "open = $openBracePos\n";
							print STDERR "depth = $braceLevel\n";
						}
						#print "\[$_\]\n";
						$_ =~ s/\{//; # stip it
						$braceLevel++;
					}
				}
				#print "\[$_\]\n";
			} # End of while (/[\}\{]/) - ie. no more '{' or '}'
			# are present in this line
			if ($notDone > 0)
			{
				$_ = ""; # dont forget to do this ;)
				&rdln;
				#print "$_";
			}
			#print "depth = $braceLevel\n";
		} # End of while($notDone > 0) - ie. still searching for the closing
		# brace, which marks the end of the current block
		# We had such a big loop because braces can be nested ;)
		#print "Block extracted\n";
		#print "<block>$block</block>\n";

	} # End of if (/\{/)
	if ($debug)
	{
		print STDERR "</ExtractingBlock>\n";
	}
	return $block;
}

# NOTE that the special C++ and special C comments
# are not needed because these are adding an additional
# functionality of writing doc inside C/C++ comments
sub stripComment {
	local ($extraCharRead);
	local ($text);
	local ($nonCommentedPart);

	$extraCharRead = "";
  if (s|//\*\s+||) {
    # Special C++ comment
	# The use of special comment are to enable having doc in 
	# comments so for ex. doxygen/scandoc
    # &handleCommentLine( $' );
	#print "special C++ comment\n";
    #$_ = ''; &rdln;
  }	
  elsif (s|//.*||) { 
		#s|//.*||; # Eat comments
    # Ordinary C++ comment
	#print "Ordinary C++ comment\n";
    #$_ = '';
    #&rdln;
  }
  elsif (s|\/\*\*\s+||) {
    # Special C comments
		if ($debug)
		{
			print STDERR "special C comment\n";
		}
    
		$nonCommentedPart = substr($_,0,$-[0]);

    s/\={3,}|\-{3,}|\*{3,}//;			# Eliminate banner strips
    $text = '';
    
    # Special comment
    while (!/\*\//)
	{ 
	# The use of special comment are to enable having doc in 
	# comments so for ex. doxygen/scandoc
		#&handleCommentLine( $_ );
		$text .= $_; 
		$_ = <FILE>; 
		$extraCharRead .= $_;
		$linenumber++;
		if ($debug)
		{
			print STDERR "(1) $linenumber\n."; 
		}
	}
    s/\={3,}|\-{3,}|\*{3,}//;			# Eliminate banner strips
    /\*\//;
	# The use of special comment are to enable having doc in 
	# comments so for ex. doxygen/scandoc
    #&handleCommentLine( $` );
    $text.= $`; $_ = $nonCommentedPart . $';
  }
  elsif (s|\/\*||) {
    # Ordinary C comment
		if ($debug)
		{
			print STDERR "..Ordinary C comment..";
			print STDERR "\$_=[$_]...";
		}
    $text = "";
		$nonCommentedPart = substr($_,0,$-[0]);
		if ($debug)
		{
			print STDERR "$+[0], $-[0] ...";
			print STDERR "\$nonCommentedPart=[$nonCommentedPart]...";
		}
    
    while (!/\*\//)
	{
		$text .= $_;
		$_ = <FILE>;
		$extraCharRead .= $_;
		$linenumber++;
		if ($debug)
		{
			print STDERR "(2) $linenumber\n.";
		}
	}
    /\*\//;
    $text.= $`;
		if ($debug)
		{
			print STDERR "\$text=[$text]...";
		}
	# $` contains everything from the beginning till just before
	# the pattern matched (this will slow down parsing, use $-[0],etc
	# instead - see perldoc->regex tut
	#print "\$`=$`\n";
	
	# $text contains everything inside comments
	#print "\$text=$text\n";
	$_ = $nonCommentedPart . $';
  }
	return $extraCharRead;
}


sub getNumCases {

	local ($tmpblock);
	local ($block);
	my ($block) = @_;


	if (0)
	{
		$block =~ /\{/;
		$bodystart = $-[0]+1; # one position after '{' (reason for +1)
		$block =~ /\}/;
		$bodyend = $-[0]-1; # one position before '}' (reason for -1)
		$body = substr($block, $bodystart,$bodyend-$bodystart+1);
		# print STDERR "<body>$body</body>\n";
		#$numSwitchCases = &calNumSwitchCases;
		$_ = $body;
		$numSwitchCases = 0;
		$_ =~ s/([\;\{]\s*case\s*\w*\s*:)/$numSwitchCases++;$1/eg;  # final $1 replaces "case" with itself
		# print "num cases = $numSwitchCases\n";
		$_ = substr($block, $bodyend+2); # skip over '}'
	}
	else
	{
		#$tmpblock = &stripBlockComment($block);
		$tmpblock = $block;
		$numSwitchCases = 0;
		$switchCases = "";
		#print "<tmpblock>$tmpblock</tmpblock>\n";
		if (1)
		{
		# note the following 
		# ex1.-------------
		# case abc:
		# case bcd:
		# ex2.-------------
		# switch (a){
		# case abd:
		# ex3.-------------
		# case abd:
		#		break;
		#	case bcd: 
		#	NOTE: the instruction assumes that the ';' is after 'break'
		#	and not any other identifier (good assumption if the program
		#	is known to compile ;)) - will fix it later FIXME
			#$_ =~ s/([\;\:\{]\s*case\s*\w*\s*)[^:]/$numSwitchCases++;$1/eg;  # final $1 replaces "case" with itself
			# The following did not work correctly and resulted in one last character short
			#$_ =~ s/([\;\:\{]\s*case\s*(\w*\s*[^:]))/{$numSwitchCases++;print "[$2]\n";};$1/eg;
			#$tmpblock =~ s/([\;\:\{]\s*case\s*(\w*\s*[^:]))/{$numSwitchCases++;$switchCases .=$2."-";};$1/eg;  # final $1 replaces "case" with itself
			$tmpblock =~ s/(([\;\:\{]|\*\/)\s*case\s*(\w*\s*[^:]))/{$numSwitchCases++;$switchCases .=$3."-";};$1/eg;  # final $1 replaces "case" with itself
			$tmpblock =~ s/(([\;\:\{]|\*\/)\s*default\s*\:)/{$numSwitchCases++;$switchCases .= "default-";};$1/eg;  # final $1 replaces "case" with itself
			#print "$numSwitchCases=>[$switchCases]\n";
		}
		else
		{
		# NOTE here we consider
		# case abc:
		# case bcd:
		#   as one case because there will be only one testgroup for both of them.
			$tmpblock =~ s/([\;\{]\s*case\s*(\w*\s*))/{$numSwitchCases++;$switchCases .=$2."-";};$1/eg;  # final $1 replaces "case" with itself
		}
		#print "num cases = $numSwitchCases\n";
		# find the position of the last '}' in the block
		$_ = $block;
		while (/\}/)
		{
			$bodyend = $-[0];
			#print "-- $bodyend\n";
			$_ = substr($_, $bodyend+1); # skip over the '}'
		}
		#print "\$_=[$_]\n";
		#$_ = "";
		if (defined ($_))
		{
			#print "\$_=[$_]\n";
		}
		else
		{
			$_ = "";
		}
		#print "[$_]\n";
		#$_ = ""; 
	}
	return ($numSwitchCases,$switchCases);

}

sub genUnitTestFramework {

	local ($depth);

	$fname = "test_" . $suitename . ".xml";
  #print "\$suitename=$suitename----\n";
  #print "\$fname=$fname\n";
	&newfile($fname);

if (0)
{
# ROBODOC header for functions
	$robodoc_func_header = "/****f* Suite_<suitename>/test_<name> [1.0] *\n";
	$robodoc_func_header .= "*  NAME\n";
	$robodoc_func_header .= "*    test_<name> - Unit test function for function <name>. \n";
	$robodoc_func_header .= "*  SYNOPSIS\n";
	$robodoc_func_header .= "*    START_TEST(test_<name>)\n";
	$robodoc_func_header .= "*  FUNCTION\n";
	$robodoc_func_header .= "*    This function ... \n";
	#$robodoc_func_header .= "*  INPUTS\n";
	#$robodoc_func_header .= "*  RESULT\n";
	$robodoc_func_header .= "*  EXAMPLE\n";
	$robodoc_func_header .= "*  NOTES\n";
	$robodoc_func_header .= "*  BUGS\n";
	$robodoc_func_header .= "*  SEE ALSO\n";
	$robodoc_func_header .= "*  SOURCE\n";
	$robodoc_func_header .= "*/\n";
	$robodoc_footer = "/************/\n";
}	
	$depth = 0;
	print FOUT "<?xml version='1.0'?>\n";
	print FOUT "<!DOCTYPE suite SYSTEM \"$xmlscriptdtd\">\n"; 
	print FOUT &addIndent($depth) . "<suite>\n";
	print FOUT &addIndent($depth) . "<suitename>$suitename</suitename>\n";
	# Global
	$global .=  "\t<!-- *\n";
	$global .=  "\t * This file is a testsuite \"$suitename\" for testing\n";
	$global .=  "\t * file $filename\n";
	$global .=  "\t *\n";
	$global .=  "\t * Author:\n";
	$global .=  "\t *   Neeraj Sharma\n";
	$global .=  "\t -->\n";
	print FOUT $global;
	$depth++;

	$setup .=  "{\n";
	$setup .=  "    /* write setup code here */\n";
	$setup .=  "}\n";
	#print $setup;
	$teardown .=  "{\n";
	$teardown .=  "    /* write teardown code here */\n";
	$teardown .=  "}\n";
	#print $teardown;

	$fproto = "";
	$numCases = 0;
	$_ = $parseResult;
	$tcaseDecl = "";
	$tcaseCall = "";
	$tcaseAdds = "";
	$testAdds = "";
	while (/^\w*\s*\w*\(.*\)\;/)
	{
		# Process a prototype
		/^\w*\s*/;
		$fntype = substr($_, $-[0], $+[0]-$-[0]);
		$fntype =~ s/\s*//g; # strip wide space
		s/^\w*\s*//;
		/^\w*/;
		$fnname = substr($_, $-[0], $+[0]-$-[0]);
		if ($debug)
		{
			print "$fntype $fnname(..)\n";
		}
		s/^\w*//;
		s/^(\s*|)\(//;
		$fargs = "";
		$argDecl = "\t$fntype ret;\n";
		# now get the arguments
		#while (/^(\s*|)(\w*(\s*|)(\*|)(\s*|)\w*|\))/)
		while (!/^\;/)
		{
		  if (0)
		  { # this method cannot parse
			# declarations like "const char a" and other complex declarations
			if (/^(\s*|)\)\;/)
			{
				s/^(\s*|)\)//; # dont consume ';'
			}
			else
			{
			#	/^(\s*|)\w*(\s*|)(\*|)(\s*|)\w*/;
				/^(\s*|)\w*(\s*|)(\*|)(\s*|)/;
				$argType = substr($_,$-[0], $+[0]-$-[0]);
				s/^(\s*|)\w*(\s*|)(\*|)(\s*|)//;
				#print "$argType\n";
				#/^\w*/;
				/^\w*(\s*|)(\[(\s*|)(\w*|)(\s*|)\]|)/;
				$argName = substr($_,$-[0], $+[0]-$-[0]);
				s/^\w*(\s*|)(\[(\s*|)(\w*|)(\s*|)\]|)//;
				s/^\,//;
				if ($debug)
				{
					print "$argType $argName; ";
				}
				#print "\$_=->$_<-\n";
			}
		  }
		  else
		  {
			# This method cannot parse pointer to function declaration
			# to fix that modify the comparison on $decl
			# which is
			#   $decl =~/ \s*\w*(\s*|)(\[(\s*|)(\w*|)(\s*|)\]|)(\s*|)$/;
			/(\,.|\)\;)/;
			$decl = substr($_,0,$-[0]); # not including the last two char (ie. ',' '(any)' or ')' ';')
			#print "\$decl=[$decl]\n";
			$_ = substr($_,$-[0]+1);  # do not include ',' or ')', but include the next char
			#print "$_\n";
			# Note that $decl does not contain ',' or ");"
			$decl =~/\s*\w*(\s*|)(\[(\s*|)(\w*|)(\s*|)\]|)(\s*|)$/;
			$argType = substr($decl, 0, $-[0]);
			$argName = substr($decl, $-[0],$+[0]-$-[0]);
			# strip leading wide space
			$argType =~ s/^\s*//;
			$argName =~ s/^\s*//;
			# remove the "const" from argument type
			$argType =~ s/^const\s*//;
			$argDecl .= "\t$argType $argName;\n";
			if ($debug)
			{
				print "\t$argType $argName;\n";
			}
			$fargs .= $argName . ",";
			# strip the [..] in the name of the argument when
			# they are passed to the function under test
			$fargs =~ s/(\s*|)\[(\s*|)(\w*|)(\s*|)\](\s*|)//;
		  }
		}
		s/^\;//;
		if ($debug)
		{
			print "\n";
		}
		/^\d*\;/;
		$numCases = substr($_, $-[0], $+[0]-$-[0]-1); # not including ';'
		$_ = substr($_, $+[0]);
		/^(\w|\-)*\;/;
		$switchCases = substr($_, $-[0], $+[0]-$-[0]-1); # not including ';'
		$_ = substr($_, $+[0]);
		#print "$switchCases\n";
		$fargs =~ s/\,$//; # strip the last unwanted ','
		# No switch case is equivalent to 1 switch case
		if ($numCases == 0)
		{ $numCases = 1; }
		$counter = 0; 
		# for creating more than one test
		# for one function
		print FOUT &addIndent($depth) . "<testgroup>\n";
		$depth++;
		print FOUT &addIndent($depth) . "<name>$fnname</name>\n";
		&printSetupTeardown($setup,$teardown,"unchecked",$depth);
		&printSetupTeardown($setup,$teardown,"checked",$depth);
		while ($counter < $numCases)
		{
				$counter++;
				if (0)
				{
				$robodoc_comment = $robodoc_func_header;
				$robodoc_comment =~ s/\<suitename\>/$suitename/g;
				$robodoc_comment =~ s/\<name\>/$fnname$counter/g;
				}

				$switchCases =~ /^(\w*)\-/;
				$switchCaseName = $1;
				if ($debug)
				{
					print "case name =$switchCaseName \n";
				}
				$switchCases =~ s/(\w*)\-//;

				print FOUT &addIndent($depth) . "<test>\n";
				$depth++;
				print FOUT &addIndent($depth) . "<index>$counter</index>\n";
				print FOUT &addIndent($depth) . "<label>$switchCaseName</label>\n";
				if (0)
				{
				print FOUT "<robodoc_header>\n";
				print FOUT $robodoc_comment;
				print FOUT "</robodoc_header>\n";
				print FOUT "<robodoc_footer>\n";
				print FOUT $robodoc_footer;
				print FOUT "</robodoc_footer>\n";
				}
				print FOUT &addIndent($depth) . "<doc>\n";
				$depth++;
				print FOUT &addIndent($depth) . "<title> Write One line description </title>\n";
				print FOUT &addIndent($depth) . "<function>\nWrite multiline function of this subroutine\n";
				print FOUT &addIndent($depth) . "</function>\n";
				print FOUT &addIndent($depth) . "<notes>\nWrite notes here\n";
				print FOUT &addIndent($depth) . "</notes>\n";
				print FOUT &addIndent($depth) . "<bugs>\nWrite bugs here\n";
				print FOUT &addIndent($depth) . "</bugs>\n";
				print FOUT &addIndent($depth) . "<seealso>\nWrite SEE ALSO here\n";
				print FOUT &addIndent($depth) . "</seealso>\n";
				print FOUT &addIndent($depth) . "<todo>\nWrite TODO's here\n";
				print FOUT &addIndent($depth) . "</todo>\n";
				print FOUT &addIndent($depth) . "<initialconditions>\n";
				$depth++;
				print FOUT &addIndent($depth) . "<data> an initial condition </data>\n";
				$depth--;
				print FOUT &addIndent($depth) . "</initialconditions>\n";
				print FOUT &addIndent($depth) . "<inputvectors>\n";
				$depth++;
				print FOUT &addIndent($depth) . "<data> an input vector </data>\n";
				$depth--;
				print FOUT &addIndent($depth) . "</inputvectors>\n";
				print FOUT &addIndent($depth) . "<expectedresults>\n";
				$depth++;
				print FOUT &addIndent($depth) . "<data> an expected result </data>\n";
				$depth--;
				print FOUT &addIndent($depth) . "</expectedresults>\n";
				$depth--;
				print FOUT &addIndent($depth) . "</doc>\n";
				#print FOUT "\t<suitename>$suitename</suitename>\n";
				print FOUT &addIndent($depth) . "<code>\n";
				$depth++;
				print FOUT &addIndent($depth) . "<decl>\n";
				$depth++;
				print FOUT &addIndent($depth) . "<auto>\n";
				print FOUT "<!--\n";
				print FOUT "\t/* Start of variable declaration used by function\n";
				print FOUT "\t * under test.\n";
				print FOUT "\t */\n";
				print FOUT "$argDecl";
				print FOUT "\t/* End of variable declaration used by function\n";
				print FOUT "\t * under test.\n";
				print FOUT "\t */\n";
				print FOUT "-->\n";
				print FOUT &addIndent($depth) . "</auto>\n";
				print FOUT &addIndent($depth) . "<custom>\n";
				print FOUT "<!--\n";
				print FOUT "\t/* Write additional declarations here */\n";
				print FOUT "-->\n";
				print FOUT &addIndent($depth) . "</custom>\n";
				$depth--;
				print FOUT &addIndent($depth) . "</decl>\n";
				print FOUT &addIndent($depth) . "<init>\n";
				print FOUT "<!--\n";
				print FOUT "\t/* Test specific initialization goes here */\n";
				print FOUT "-->\n";
				print FOUT &addIndent($depth) . "</init>\n";
				print FOUT &addIndent($depth) . "<call>\n";
				print FOUT "<!--\n";
				print FOUT "\t/* Consider the present state $switchCaseName */\n";
				print FOUT "\t/* Call the function under test.*/\n";
				print FOUT "\tret = $fnname($fargs);\n";
				print FOUT "-->\n";
				print FOUT &addIndent($depth) . "</call>\n";
				print FOUT &addIndent($depth) . "<exit>\n";
				print FOUT "<!--\n";
				print FOUT "\t/* Test case result analysis goes here */\n";
				print FOUT "-->\n";
				print FOUT &addIndent($depth) . "</exit>\n";
				$depth--;
				print FOUT &addIndent($depth) . "</code>\n";
				$depth--;
				print FOUT &addIndent($depth) . "</test>\n";
		}
		$depth--;
		print FOUT &addIndent($depth) . "</testgroup>\n";
	}
	print FOUT &addIndent($depth) . "</suite>\n";
}

# Open a new output file
sub newfile {
  my ($mfile) = @_;
  
	my ($fullfilename);
	$fullfilename = $destPath . $mfile;
  open( FOUT, ">$fullfilename" ) || die "Error writing to $fullfilename\n";
}

sub addIndent {
	local($tabs);
	local($str);
	my($tabs) = @_;
	
	$str = "";
	if ($tabs > 0)
	{
		while($tabs)
		{
			$str .= "\t";
			$tabs--;
		}
	}
	return $str;
}

# NOT COMPLETE..... DEBUG IT....
sub stripBlockComment {
	
	local ($text);
	local ($tmp);
	local ($commentedtext);
	local ($nonCommentedPart);
	local ($block);
	my ($block) = @_;

	while ($block =~ /\/\*/)
	{
		if ($block =~ s|//\*\s+||) {
			# Special C++ comment
			# The use of special comment are to enable having doc in 
			# comments so for ex. doxygen/scandoc
			# &handleCommentLine( $' );
			#print "special C++ comment\n";
			#$_ = ''; &rdln;
		}	
		elsif ($block =~ s|//.*||) { 
			#s|//.*||; # Eat comments
			# Ordinary C++ comment
			#print "Ordinary C++ comment\n";
			#$_ = '';
			#&rdln;
		}
		elsif ($block =~ s|\/\*||) {
			# Ordinary C comment
			if ($debug)
			{
				print STDERR "..Ordinary C comment..";
				print STDERR "\$_=[$_]...";
			}
			$text = "";
			$nonCommentedPart = substr($block,0,$-[0]);
				print "\$nonCommentedPart=[$nonCommentedPart]";
			$block = substr($block,$-[0]);
			if ($debug)
			{
				print STDERR "$+[0], $-[0] ...";
				print STDERR "\$nonCommentedPart=[$nonCommentedPart]...";
			}
			
			$block =~ /\*\//;
			$text = substr($block,0,$-[0]);
			if ($debug)
			{
				print STDERR "\$text=[$text]...";
			}
				$tmp = substr($block,$+[0]);
				#print "after=[[$tmp]]...";
		
			# $` contains everything from the beginning till just before
			# the pattern matched (this will slow down parsing, use $-[0],etc
			# instead - see perldoc->regex tut
			#print "\$`=$`\n";
		
			# $text contains everything inside comments
			print "\$text=$text...\n";
			$block = $nonCommentedPart . $tmp;
		}
	}
		if (1)
		{
			print "<block>$block</block>\n";
		}
		return $block;
}

sub printSetupTeardown {
	local ($setup,$teardown,$type,$depth);
	local ($tmp);
	my ($setup,$teardown,$type, $depth) = @_;

	print FOUT &addIndent($depth) . "<setup type=\"$type\">\n";
	$depth++;
	print FOUT &addIndent($depth) . "<doc>\n";
	$depth++;
	print FOUT &addIndent($depth) . "<title> Write One line description </title>\n";
	print FOUT &addIndent($depth) . "<function>\nWrite multiline function of this subroutine\n";
	print FOUT &addIndent($depth) . "</function>\n";
	print FOUT &addIndent($depth) . "<notes>\nWrite notes here\n";
	print FOUT &addIndent($depth) . "</notes>\n";
	print FOUT &addIndent($depth) . "<bugs>\nWrite bugs here\n";
	print FOUT &addIndent($depth) . "</bugs>\n";
	print FOUT &addIndent($depth) . "<seealso>\nWrite SEE ALSO here\n";
	print FOUT &addIndent($depth) . "</seealso>\n";
	print FOUT &addIndent($depth) . "<todo>\nWrite TODO's here\n";
	print FOUT &addIndent($depth) . "</todo>\n";
	$depth--;
	print FOUT &addIndent($depth) . "</doc>\n";
	print FOUT &addIndent($depth) . "<data>\n";
	print FOUT "<!--\n";
	$tmp = $setup;
	#$tmp =~ s/\<name\>/$fnname/;
	print FOUT $tmp;
	print FOUT "-->\n";
	print FOUT &addIndent($depth) . "</data>\n";
	$depth--;
	print FOUT &addIndent($depth) . "</setup>\n";
	print FOUT &addIndent($depth) . "<teardown type=\"$type\">\n";
	$depth++;
	print FOUT &addIndent($depth) . "<doc>\n";
	$depth++;
	print FOUT &addIndent($depth) . "<title> Write One line description </title>\n";
	print FOUT &addIndent($depth) . "<function>\nWrite multiline function of this subroutine\n";
	print FOUT &addIndent($depth) . "</function>\n";
	print FOUT &addIndent($depth) . "<notes>\nWrite notes here\n";
	print FOUT &addIndent($depth) . "</notes>\n";
	print FOUT &addIndent($depth) . "<bugs>\nWrite bugs here\n";
	print FOUT &addIndent($depth) . "</bugs>\n";
	print FOUT &addIndent($depth) . "<seealso>\nWrite SEE ALSO here\n";
	print FOUT &addIndent($depth) . "</seealso>\n";
	print FOUT &addIndent($depth) . "<todo>\nWrite TODO's here\n";
	print FOUT &addIndent($depth) . "</todo>\n";
	$depth--;
	print FOUT &addIndent($depth) . "</doc>\n";
	print FOUT &addIndent($depth) . "<data>\n";
	print FOUT "<!--\n";
	$tmp = $teardown;
	$tmp =~ s/\<name\>/$fnname/;
	print FOUT $tmp;
	print FOUT "-->\n";
	print FOUT &addIndent($depth) . "</data>\n";
	$depth--;
	print FOUT &addIndent($depth) . "</teardown>\n";

}
